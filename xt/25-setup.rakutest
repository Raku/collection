use Test;
use File::Directory::Tree;
use Test::Deeply::Relaxed;

use Collection;
constant TMP = 'xt/test-dir';
constant MODE = 'test-mode';

bail-out "{ TMP } must exist. Have pre-render tests been run?"
unless TMP.IO.d;

chdir TMP;

plan 7;
my $rv;

# add a mode directory, with its config files, and plugins directory and some setup plugins
if MODE.IO.d { empty-directory MODE }
else { mktree MODE }
mktree MODE ~ '/m-sources';
(MODE ~ '/m-sources/index.rakudoc').IO.spurt(q:to/IND/);
        =begin pod
        =TITLE An index

        =MyIndex :custom<header>

        =end pod
        IND

my @pls = <setup1 setup_rend rend2 reporter compiler completer unused gather-css asset-mover image-mover>;
mktree MODE ~ '/configs';
mktree(MODE ~ "/some-plugs/$_") for @pls;
(MODE ~ '/configs/01-basic.raku').IO.spurt(qq:to/CONF/);
    %(
        :mode-cache<m-cache>,
        :mode-sources<m-sources>,
        :no-refresh, # for test dont want to refresh or obtain
        :no-preserve-state,
        :!recompile,
        :mode-ignore(),
        :mode-obtain(),
        :mode-refresh(),
        :mode-extensions<rakudoc pod6>,
        :!full-render,
        :!without-report,
        :!without-processing,
        :plugins<some-plugs>,
        :report-path<reports>,
        :templates<templates>,
    );
    CONF

(MODE ~ '/configs/02-plugin.raku').IO.spurt(qq:to/CONF/);
    %(
        plugins-required => %(
            :setup(<setup1 setup_rend>),
            :render(<setup_rend rend2 reporter gather-css asset-mover image-mover>),
            :compilation(<compiler>,),
            :transfer(<image-mover gather-css>),
            :report(<reporter>,),
            :completion(<completer>,),
        ),
    );
    CONF

(MODE ~ '/configs/03-completion-options.raku').IO.spurt(qq:to/CONF/);
    %(
        :!without-completion,
        :destination<html>,
        :landing-place<index>,
        :output-ext<html>,
        completion-options => %(
            :port<30000>,
            :host<localhost>,
        )
    );
    CONF

for @pls {
    (MODE ~ "/some-plugs/$_/config.raku").IO.spurt(qq:to/CONF/);
        %(
            { given $_ {
                when 'setup1' { "setup => \'proc.raku\' " }
                when 'setup_rend' { "render => True, setup => \'proc.raku\' " }
                when 'reporter' { "report => True" }
                when 'compiler' { "compilation => True" }
                when 'completer' { "completion => True " }
                when 'gather-css' { "render => False" }
                when 'asset-mover' { "render => False" }
                when 'image-mover' { "render => False" }
                default { "report => True, css => 'some-styling.css', " }
            } },
        );
        CONF
}
=begin pod
=TITLE This is a test file

Some stuff

=head1 Header One

Here an X<I have indexed this|index1> some stuff
=end pod
=begin pod
=TITLE Another file

A little rubbish

=head1 Header Two

This is a link L<Somewhere stupid|https://nowhere.net.nul>.

This is a N<Footnote> for prosperity.

=end pod

my $p = 0;
for <setup1 setup_rend> {
    (MODE ~ "/some-plugs/$_/proc.raku").IO.spurt(qq:to/CONF/);
        sub ( \$cache, \$coll, \$full, \$s-root, \$m-root, \%options ) \{
                \$cache.add( \"\$s-root/extra_{ $p }_{ $_ }\", [{ $=pod[$p++].raku }] );
        \}
        CONF

}

$rv = collect(MODE, :no-status, :after<mode>, :no-preserve-state, :recompile);
is $rv[1][0]<Mode>[0]<message>, 'No plugins defined', 'Mode plugin message correct';

$rv = collect(MODE, :no-status, :before<setup>, :no-preserve-state, :recompile);
#recompile to ensure that the cache is emptied
is $rv.elems, 2, 'collect should return 2 elems';
is $rv[0].elems, 5, 'collect should return 5 elems at setup';
isa-ok $rv[0][0], Pod::From::Cache, 'first of list';
isa-ok $rv[0][1], Pod::From::Cache, 'second of list';

is-deeply-relaxed
        $rv[0][0].list-changed-files.Set,
        <sources/extra_0_setup1 sources/extra_1_setup_rend>.Set,
        'cache altered';
isa-ok $rv[0][0].pod('sources/extra_1_setup_rend')[0], Pod::Block, 'retrieved Pod::Block from first extra';

done-testing;
